// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package generated

import "encoding/json"
import "fmt"
import "reflect"
import "regexp"

type Edge struct {
	// Optional condition for edge traversal
	Condition *string `json:"condition,omitempty" yaml:"condition,omitempty" mapstructure:"condition,omitempty"`

	// Source node ID
	From string `json:"from" yaml:"from" mapstructure:"from"`

	// Target node ID
	To string `json:"to" yaml:"to" mapstructure:"to"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Edge) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["from"]; raw != nil && !ok {
		return fmt.Errorf("field from in Edge: required")
	}
	if _, ok := raw["to"]; raw != nil && !ok {
		return fmt.Errorf("field to in Edge: required")
	}
	type Plain Edge
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	*j = Edge(plain)
	return nil
}

type Node struct {
	// Node-specific configuration
	Config map[string]interface{} `json:"config,omitempty" yaml:"config,omitempty" mapstructure:"config,omitempty"`

	// Unique identifier for the node
	Id string `json:"id" yaml:"id" mapstructure:"id"`

	// Retry corresponds to the JSON schema field "retry".
	Retry *RetryPolicy `json:"retry,omitempty" yaml:"retry,omitempty" mapstructure:"retry,omitempty"`

	// Execution timeout in milliseconds
	TimeoutMs *int `json:"timeout_ms,omitempty" yaml:"timeout_ms,omitempty" mapstructure:"timeout_ms,omitempty"`

	// Type of the node
	Type NodeType `json:"type" yaml:"type" mapstructure:"type"`
}

type NodeType string

const NodeTypeAggregate NodeType = "aggregate"
const NodeTypeConditional NodeType = "conditional"
const NodeTypeFilter NodeType = "filter"
const NodeTypeFunction NodeType = "function"
const NodeTypeHttp NodeType = "http"
const NodeTypeLoop NodeType = "loop"
const NodeTypeParallel NodeType = "parallel"
const NodeTypeTransform NodeType = "transform"

var enumValues_NodeType = []interface{}{
	"function",
	"http",
	"conditional",
	"loop",
	"parallel",
	"transform",
	"aggregate",
	"filter",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NodeType) UnmarshalJSON(value []byte) error {
	var v string
	if err := json.Unmarshal(value, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NodeType, v)
	}
	*j = NodeType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Node) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["id"]; raw != nil && !ok {
		return fmt.Errorf("field id in Node: required")
	}
	if _, ok := raw["type"]; raw != nil && !ok {
		return fmt.Errorf("field type in Node: required")
	}
	type Plain Node
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if matched, _ := regexp.MatchString(`^[a-zA-Z0-9_-]+$`, string(plain.Id)); !matched {
		return fmt.Errorf("field %s pattern match: must match %s", "Id", `^[a-zA-Z0-9_-]+$`)
	}
	if plain.TimeoutMs != nil && 0 > *plain.TimeoutMs {
		return fmt.Errorf("field %s: must be >= %v", "timeout_ms", 0)
	}
	*j = Node(plain)
	return nil
}

type RetryPolicy struct {
	// BackoffMs corresponds to the JSON schema field "backoff_ms".
	BackoffMs int `json:"backoff_ms,omitempty" yaml:"backoff_ms,omitempty" mapstructure:"backoff_ms,omitempty"`

	// BackoffMultiplier corresponds to the JSON schema field "backoff_multiplier".
	BackoffMultiplier float64 `json:"backoff_multiplier,omitempty" yaml:"backoff_multiplier,omitempty" mapstructure:"backoff_multiplier,omitempty"`

	// MaxAttempts corresponds to the JSON schema field "max_attempts".
	MaxAttempts int `json:"max_attempts,omitempty" yaml:"max_attempts,omitempty" mapstructure:"max_attempts,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RetryPolicy) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	type Plain RetryPolicy
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if v, ok := raw["backoff_ms"]; !ok || v == nil {
		plain.BackoffMs = 1000.0
	}
	if 0 > plain.BackoffMs {
		return fmt.Errorf("field %s: must be >= %v", "backoff_ms", 0)
	}
	if v, ok := raw["backoff_multiplier"]; !ok || v == nil {
		plain.BackoffMultiplier = 2.0
	}
	if 1 > plain.BackoffMultiplier {
		return fmt.Errorf("field %s: must be >= %v", "backoff_multiplier", 1)
	}
	if v, ok := raw["max_attempts"]; !ok || v == nil {
		plain.MaxAttempts = 3.0
	}
	if 10 < plain.MaxAttempts {
		return fmt.Errorf("field %s: must be <= %v", "max_attempts", 10)
	}
	if 1 > plain.MaxAttempts {
		return fmt.Errorf("field %s: must be >= %v", "max_attempts", 1)
	}
	*j = RetryPolicy(plain)
	return nil
}

// A directed acyclic graph (DAG) representing a workflow
type WorkflowSchemaJson struct {
	// List of edges connecting nodes
	Edges []Edge `json:"edges" yaml:"edges" mapstructure:"edges"`

	// Optional workflow metadata
	Metadata *WorkflowSchemaJsonMetadata `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// List of nodes in the workflow
	Nodes []Node `json:"nodes" yaml:"nodes" mapstructure:"nodes"`
}

// Optional workflow metadata
type WorkflowSchemaJsonMetadata struct {
	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []string `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Version corresponds to the JSON schema field "version".
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *WorkflowSchemaJson) UnmarshalJSON(value []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(value, &raw); err != nil {
		return err
	}
	if _, ok := raw["edges"]; raw != nil && !ok {
		return fmt.Errorf("field edges in WorkflowSchemaJson: required")
	}
	if _, ok := raw["nodes"]; raw != nil && !ok {
		return fmt.Errorf("field nodes in WorkflowSchemaJson: required")
	}
	type Plain WorkflowSchemaJson
	var plain Plain
	if err := json.Unmarshal(value, &plain); err != nil {
		return err
	}
	if plain.Nodes != nil && len(plain.Nodes) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "nodes", 1)
	}
	*j = WorkflowSchemaJson(plain)
	return nil
}
